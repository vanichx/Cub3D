#include <stdio.h>
#include <stdbool.h>

#define MAP_WIDTH 30
#define MAP_HEIGHT 15

// Function to check if the map is enclosed by walls
bool is_map_enclosed(char map[MAP_HEIGHT][MAP_WIDTH]) {
    // Mark all cells as unvisited
    bool visited[MAP_HEIGHT][MAP_WIDTH] = {{false}};

    // Identify the bounding box
    int min_x = MAP_WIDTH - 1, min_y = MAP_HEIGHT - 1;
    int max_x = 0, max_y = 0;

    // Find the bounding box
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            if (map[y][x] == '1') {
                if (x < min_x) min_x = x;
                if (y < min_y) min_y = y;
                if (x > max_x) max_x = x;
                if (y > max_y) max_y = y;
            }
        }
    }

    // Initialize stack with boundary cells
    int stack[MAP_WIDTH * MAP_HEIGHT * 2];
    int top = -1;

    // Push boundary cells onto the stack
    for (int x = min_x - 1; x <= max_x + 1; x++) {
        if (x >= 0 && x < MAP_WIDTH) {
            if (min_y - 1 >= 0) {
                stack[++top] = x;
                stack[++top] = min_y - 1;
            }
            if (max_y + 1 < MAP_HEIGHT) {
                stack[++top] = x;
                stack[++top] = max_y + 1;
            }
        }
    }
    for (int y = min_y - 1; y <= max_y + 1; y++) {
        if (y >= 0 && y < MAP_HEIGHT) {
            if (min_x - 1 >= 0) {
                stack[++top] = min_x - 1;
                stack[++top] = y;
            }
            if (max_x + 1 < MAP_WIDTH) {
                stack[++top] = max_x + 1;
                stack[++top] = y;
            }
        }
    }

    // Process each cell in the stack
    while (top >= 0) {
        int x = stack[top--];
        int y = stack[top--];

        // Mark current cell as visited
        visited[y][x] = true;

        // Check neighbors
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                int nx = x + dx;
                int ny = y + dy;

                if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT &&
                    map[ny][nx] == '0' && !visited[ny][nx]) {
                    // Push unvisited empty neighbors onto the stack
                    stack[++top] = nx;
                    stack[++top] = ny;
                }
            }
        }
    }

    // Check if any '0' cell is unvisited
    for (int y = 0; y < MAP_HEIGHT; y++) {
        for (int x = 0; x < MAP_WIDTH; x++) {
            if (map[y][x] == '0' && !visited[y][x]) {
                return false; // Map is not completely enclosed
            }
        }
    }

    return true; // Map is enclosed
}

int main() {
    char map[MAP_HEIGHT][MAP_WIDTH] = {
        "000000000111111111100000000000",
        "000000000100000000100000000000",
        "111111111100000000111111100000",
        // ... (rest of your map)
    };

    if (is_map_enclosed(map)) {
        printf("Map is enclosed by walls.\n");
    } else {
        printf("Map is not completely enclosed by walls.\n");
    }

    return 0;
}
